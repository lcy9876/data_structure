\documentclass[UTF8]{ctexart}
\usepackage{geometry, CJKutf8}
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.3cm}




\begin{document}

李春阳, 学号3230101204

{数据结构与算法第五次作业}

Nov.2th, 2024

\section{测试程序的设计思路}

我首先修改原有的remove函数为removeold

新编写了remove函数

用非递归实现BST树的删除操作

从一棵二叉搜索树中删除一个节点之前必须先找到该节点所在的位置

	删除操作会引起很多后果 , 主要来自两个方面 :
    
	一方面删除树中的一个节点必然会导致原本连通的树结构发生阻隔
    
	其次 , 当二叉搜索树中的某个节点被删除之后 , 树中的有序关系可能遭到破坏
    
    具体而言分为三种情况
    
	1.删除的节点没有孩子
    
	2.删除的节点只有一个孩子
    
	3.删除的节点有两个孩子
    
	1和2可以看成是一种类型 , 只有一个孩子 , 这个孩子是空(nullptr)
    
	情况三的处理方法 , 使用前驱结点或者后继节点代替该节点 , 删除前驱即可
    
	前驱结点 : 当前节点的左子树中 , 元素的最大值
    
	后继节点 : 当前节点的右子树中 , 元素的最小值
    
流程
1. 从root开始寻找值为val的节点，cur指向它

2. 先判断是否满足情况3，如果满足，需要找cur的前驱节点，用前驱把cur节点的值给覆盖掉

直接删前驱

3. 删除情况1和情况2   直接删除cur指针指向的节点就OK
\section{测试的结果}

测试结果一切正常。

我用 valgrind 进行测试，发现没有发生内存泄露。

\section{（可选）bug报告}

我没有发现 bug，：



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 